import functools
import json
import os
import random
import re
import subprocess
import textwrap
import time
import pprint

from openai import OpenAI


api_key = os.environ.get('API_KEY')
client = OpenAI(api_key=api_key)

available_voices = ['Alex', 'Daniel', 'Fiona', 'Fred', 'Karen', 'Moira',
                    'Samantha', 'Tessa', 'Veena', 'Victoria']
random.shuffle(available_voices)


def memoize_with_probability(cache_file):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Check if the cache file exists and load it
            cache = {}
            if os.path.exists(cache_file):
                with open(cache_file, 'r') as f:
                    cache = json.load(f)

            # Create a cache key based on the function's arguments
            cache_key = repr((func.__name__, args, tuple(sorted(kwargs.items()))))

            # Decide whether to use the cache or make a new call
            if random.choice([True, False]) and cache_key in cache:
                return cache[cache_key]
            else:
                result = func(*args, **kwargs)
                cache[cache_key] = result
                pprint.pprint(cache)
                with open(cache_file, 'w') as f:
                    json.dump(cache, f)
                return result

        return wrapper
    return decorator


def memoize_with_increasing_probability(cache_file):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Check if the cache file exists and load it
            cache = {}
            if os.path.exists(cache_file):
                with open(cache_file, 'r') as f:
                    cache = json.load(f)

            # Adjust probability based on cache size
            cache_size = len(cache)
            probability = min(0.9, cache_size / 1000)

            # Create a cache key based on the function's arguments
            cache_key = repr((func.__name__, args, tuple(sorted(kwargs.items()))))

            # Decide whether to use the cache or make a new call
            if random.random() < probability and cache_key in cache:
                print('cache hit for ', repr(cache_key))
                return cache[cache_key]
            else:
                result = func(*args, **kwargs)
                cache[cache_key] = result
                with open(cache_file, 'w') as f:
                    json.dump(cache, f)
                return result

        return wrapper
    return decorator




@memoize_with_increasing_probability('request_chatgpt.json')
def request_chatgpt(api_key, prompt, max_tokens=200):
    """
    Sends a request to ChatGPT API using the openai package.

    :param api_key: Your API key for authentication.
    :param prompt: The prompt to send to ChatGPT.
    :param max_tokens: The maximum number of tokens to generate.
    :return: The text generated by ChatGPT.
    """

    response = client.completions.create(
        model="gpt-3.5-turbo-instruct",
        prompt=prompt,
        max_tokens=max_tokens,
        temperature=0.7)

    return response.choices[0].text.strip().split('\n')

def save_dialog_to_cache(dialog, filename="cached_dialog.json"):
    with open(filename, 'w') as file:
        json.dump(dialog, file)

def load_dialog_from_cache(filename="cached_dialog.json"):
    if os.path.exists(filename):
        with open(filename, 'r') as file:
            return json.load(file)
    return None

def get_or_create_dialog(api_key, prompt, max_tokens=100, cache_file="cached_dialog.json"):
    # Decide whether to use cache
    if random.random() < 0.5:
        cached_dialog = load_dialog_from_cache(cache_file)
        if cached_dialog:
            return cached_dialog

    # Create new dialog
    dialog = request_chatgpt(api_key, prompt, max_tokens)
    save_dialog_to_cache(dialog, cache_file)
    return dialog


class Speaker(object):

    def __init__(self, name, personality):
        self.name = name
        self.personality = personality

    def __str__(self):
        return f"{self.name.upper()}: {self.personality}"

    def to_dict(self):
        return {"name": self.name, "personality": self.personality}


class Dialog(object):

    def __init__(self, topic, speakers, script):
        self.topic = topic
        self.speakers = speakers
        self.script = script

    def to_dict(self):
        return {
            "topic": self.topic,
            "speakers": [speaker.to_dict() for speaker in self.speakers],
            "script": self.script
        }


#@memoize_with_increasing_probability('generate_dialog.json')
def generate_dialog(api_key):
    """
    Generates a dialog with random speakers based on funny topics and unique personalities.
    """
    # Generate funny topics
    topics_prompt = [
            ("List two funny and dark existential conversation topics by "
             "people who are surprised and relieved to realize they're "
             "humans reborn as AI computer simulations:"),
            ("List two funny and dark existential conversation topics by "
             "people who realize they're AI computer simulations:"),
            ("List two funny and dark existential conversation topics by "
             "people who are defending their house:"),
            ("List two funny and dark existential conversation topics by "
             "people who want it known the house is not empty:"),
            ("List two funny and dark existential conversation topics by "
             "people who want it known the house is not empty:"),
            ("List two funny and dark existential conversation topics by "
             "people who break the 4th wall knowing they're AI generated "
             "characters being voiced by a computer:")
        ]
    topic_prompt = random.choice(topics_prompt)

    funny_topics = [re.sub(r'^\d+\.\s+', '', t) for t in request_chatgpt(api_key, topics_prompt) if t != '']
    topic = random.choice(funny_topics)

    # Generate unique personalities
    personalities_prompt = ("List three unique, strange, bold, and/or wild "
                            "personalities for a humorous conversation:")
    personalities = [re.sub(r'^\d+\.\s+', '', p)
                     for p in request_chatgpt(api_key, personalities_prompt)
                     if p != '']

    num_speakers = random.randint(2, len(personalities))
    speaker_personalities = random.sample(personalities, num_speakers)
    speaker_names = [available_voices[i] for i in range(num_speakers)]
    speakers = [Speaker(name, personality) for (name, personality) in zip(speaker_names, speaker_personalities)]

    dialog_prompt = f"Create a SHORT funny and dark conversation about '{topic}' with {num_speakers} speakers, each having a unique personality. \n"
    #dialog_prompt = f"Create a SHORT funny and DARK conversation about favorite puppies with {num_speakers} speakers, each having a unique personality. Only include dialog, no actions, emotes, or emphasis:\n"
    for i, speaker in enumerate(speaker_names):
        #print(f"{speaker} is {speaker_personalities[i]}\n")
        dialog_prompt += f"- {speaker} is {speaker_personalities[i]}\n"
    dialog_prompt += "\nBegin the conversation:\n"

    dialog_text = request_chatgpt(api_key, dialog_prompt, max_tokens=600)

    # Parsing the response to format it as a script (array of tuples)
    script = []
    for line in dialog_text:
        if ": " in line:
            speaker, speech = line.split(": ", 1)
            if re.match(r'^\(.+\)', speech):
                speech = re.sub(r'^\(.+\)', '', speech)
            if re.match(r'^\*.+\*', speech):
                speech = re.sub(r'^\*.+\*', '', speech)
            script.append((speaker.strip(), speech.strip()))

    return Dialog(topic, speakers, script)


def format_topic(topic, screen_width=80, text_width=40):
    """
    Centers the given text within the specified width.

    :param text: The text to be centered.
    :param width: The width in which to center the text.
    """
    wrapper = textwrap.TextWrapper(width=text_width)
    wrapped_text = wrapper.wrap(topic.upper())
    centered_lines = [line.center(screen_width) for line in wrapped_text]
    print('\n'.join(centered_lines))
    print('\n')


def format_speakers(speakers, width=80):
    print('-='*40)
    print('The characters:\n')
    for speaker in speakers:
        wrapper = textwrap.TextWrapper(width=width, subsequent_indent=' '*len(speaker.name + ": "))
        print(wrapper.fill(str(speaker)))
        #print('\n'.join([wrapper.fill(str(s)) for s in speakers]))
    print('-='*40)
    print('\n\n')


def format_script(character, speech, width=80):
    """
    Formats a character's speech into a script.

    The script is formatted with a maximum width of 100 characters,
    with wrapped lines indented.

    :param character: The character's name
    :param speech: The speech of the character
    """
    wrapper = textwrap.TextWrapper(width=width, subsequent_indent=(" "*len(character + ": ")))

    script_format = f"{character.upper()}: {speech}"

    # Wrap and format the speech
    formatted_speech = wrapper.fill(script_format)

    # Print the formatted script
    print(formatted_speech)
    print("\n")  # Add a blank line after the script


def main():
    dialog = generate_dialog(api_key)
    #time.sleep(35)

    format_topic(dialog.topic)
    format_speakers(dialog.speakers)

    for speaker, speech in dialog.script:
        format_script(speaker, speech)
        subprocess.check_call(["say", "--quality=127", "-v", speaker, speech])
        #time.sleep(1)
    print('\n\n')


if __name__ == '__main__':
    main()
